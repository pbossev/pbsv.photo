---
layout: fullbase.liquid
pagination:
  data: galleries.galleries
  size: 1
  alias: gallery
permalink: "{{ gallery.path }}"
eleventyComputed:
  title: "{{ gallery.short_title | default: gallery.title }} üì∏"
---

<div class="sm:px-20 md:px-32 lg:mx-auto lg:max-w-4xl xl:max-w-6xl 2xl:max-w-6xl mb-4">
  {% if gallery.type == "events" %}
    <a class="text-neutral-500 text-sm no-underline" href="/galleries">‚Üê Galleries üì∏</a>
  {% else %}
    {% include "_back.liquid" %}
  {% endif %}
  <h1 class="mt-2">{{ gallery.title }}</h1>
  {% if gallery.type == "events" %}
    <small>
      {{ gallery.date | date: "%d.%m.%Y" }} - {{ gallery.location }}
    </small>
  {% endif %}
</div>

{% if gallery.locked %}
  <!-- Password Protection Overlay -->
  <div
    id="passwordOverlay"
    class="fixed inset-0 bg-black/50 z-[9999] flex items-center justify-center"
    onclick="if(event.target === event.currentTarget) window.location.href = '/galleries/';">
    <div class="bg-neutral-900 border border-neutral-700 p-8 max-w-md w-full mx-4 relative">
      <h2 class="text-2xl mb-4 text-white">üîí Protected Gallery</h2>
      <p class="text-neutral-400 mb-6">This gallery is password protected.</p>
      <div class="relative">
        <input
          type="text"
          id="galleryPassword"
          placeholder="Enter password"
          class="w-full px-4 py-2 pr-12 bg-neutral-800 border border-neutral-700 text-white focus:outline-none focus:border-neutral-500"
          onkeypress="if(event.key==='Enter') unlockGallery()" />
        <button onclick="unlockGallery()" class="absolute right-0 top-0 h-full aspect-square bg-white text-black border-l border-neutral-700 hover:bg-neutral-200 transition-colors flex items-center justify-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="w-5 h-5"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2">
            <path d="M5 12h14M12 5l7 7-7 7" />
          </svg>
        </button>
      </div>
      <div id="passwordError" class="red text-sm hidden"></div>
    </div>
  </div>

  <script>
      const WORKER_API = 'https://auth.pbsv.photo';
      const GALLERY_FOLDER = '{{ gallery.folder }}';
      const GALLERY_PATH = '{{ gallery.path }}';
      let galleryImagesData = [];

      async function unlockGallery() {
    const password = document.getElementById('galleryPassword').value;
    const errorDiv = document.getElementById('passwordError');

    if (!password) {
      errorDiv.textContent = 'Please enter a password';
      errorDiv.classList.remove('hidden');
      return;
    }

    try {
      const response = await fetch(WORKER_API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password, galleryPath: GALLERY_FOLDER })
      });

      const data = await response.json();

      if (data.success) {
        // Store in session storage
        sessionStorage.setItem('gallery-unlocked-' + GALLERY_PATH, 'true');
        sessionStorage.setItem('gallery-images-' + GALLERY_PATH, JSON.stringify(data.images));

        // Replace placeholder URLs with real URLs
        replaceImageUrls(data.images);

        // Hide overlay
        document.getElementById('passwordOverlay').classList.add('hidden');
      } else {
        errorDiv.textContent = data.error || 'Incorrect password';
        errorDiv.classList.remove('hidden');
      }
    } catch (error) {
      console.error('Auth error:', error);
      errorDiv.textContent = 'Failed to authenticate. Please try again.';
      errorDiv.classList.remove('hidden');
    }
      }

      // Hash function for matching (must match server-side hash)
      function hashFilename(filename) {
        let hash = 0;
        for (let i = 0; i < filename.length; i++) {
          const char = filename.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash).toString(16).padStart(8, '0').slice(0, 8);
      }

      function replaceImageUrls(images) {
        // Create hash map from auth response
        const imagesByHash = {};
        images.forEach((imgData) => {
          const imageUrl = typeof imgData === 'string' ? imgData : imgData.url;
          const fileName = imageUrl.split('/').pop().split('__')[0] + '.' + imageUrl.split('.').pop();
          const hash = hashFilename(fileName);
          imagesByHash[hash] = imgData;
        });

        // Match gallery images by hash
        const galleryItems = document.querySelectorAll('.gallery-img');
        galleryItems.forEach((img, index) => {
          const hash = img.getAttribute('data-hash');
          const imgData = imagesByHash[hash];

          if (imgData) {
            const imageUrl = typeof imgData === 'string' ? imgData : imgData.url;
            const previewUrl = typeof imgData === 'string'
              ? imgData.replace(/__w\d+h\d+/, '').replace(/\.(jpg|jpeg|png)$/i, '_preview.webp')
              : imgData.preview;

            img.src = previewUrl;
            img.setAttribute('onclick', `openLightbox('${imageUrl}', ${index})`);
          }
        });

        // Update the global galleryImages array used for lightbox navigation (extract just URLs)
        galleryImages = images.map(img => typeof img === 'string' ? img : img.url);
      }

      // Check if already unlocked in this session (wait for DOM)
      document.addEventListener('DOMContentLoaded', () => {
    const cachedImages = sessionStorage.getItem('gallery-images-' + GALLERY_PATH);
    if (cachedImages) {
      const imagesData = JSON.parse(cachedImages);
      replaceImageUrls(imagesData);
      document.getElementById('passwordOverlay').classList.add('hidden');
    }
      });
  </script>
{% endif %}

{% if gallery.type == "events" %}
  <section class="gallery flex flex-wrap">
    {% assign image_index = 0 %}
    {% for img in gallery.images %}
      <div class="gallery-item relative m-0.5">
        <i class="block bg-neutral-800" style="padding-bottom:{{ img.height | times: 100 | divided_by: img.width }}%"></i>
        <img
          {% if img.id %}
          id="{{ img.id }}"
          {% endif %}
          src="{{ img.preview.url }}"
          alt="{{ gallery.title }}"
          loading="lazy"
          class="gallery-img absolute top-0 w-full h-auto object-cover cursor-pointer hover:brightness-75 transition-filter duration-200"
          {% if gallery.locked %}
          onclick=""
          {% else %}
          onclick="openLightbox('{{ img.url }}', {{ image_index }})"
          {% endif %}
          data-width="{{ img.width }}"
          data-height="{{ img.height }}"
          data-hash="{{ img.hash }}" />
      </div>
      {% assign image_index = image_index | plus: 1 %}
    {% endfor %}
  </section>

  <style > :root
  {
    --rowHeight: 120;
  }

  @media (min-width: 640px) {
    :root {
      --rowHeight: 180;
    }
  }

  @media (min-width: 1024px) {
    :root {
      --rowHeight: 250;
    }
  }

  section.gallery::after {
    content: '';
    flex-grow: 999999999;
    /* keeps justification tight */
  }

  .gallery-item {
    flex-grow: 1;
  }
</style>

<script>
    function resizeGallery() {
      const items = document.querySelectorAll(".gallery-item img");
      items.forEach(img => {
        const w = parseInt(img.dataset.width, 10);
        const h = parseInt(img.dataset.height, 10);
        const targetHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--rowHeight"), 10);
        const ratioWidth = Math.round((w * targetHeight) / h);
        img.parentElement.style.width = ratioWidth + "px";
        img.parentElement.style.flexGrow = ratioWidth;
      });
    }

    window.addEventListener("resize", resizeGallery);
    window.addEventListener("load", resizeGallery);
</script>{% else %}
<!-- Portfolio Gallery (Tailwind masonry style) -->
<div class="sm:px-20 md:px-32 lg:mx-auto lg:max-w-4xl xl:max-w-6xl">
  <div class="columns-2 xl:columns-3 gap-1 space-y-1">
    {% assign image_index = 0 %}
    {% for img in gallery.images %}
      <div class="relative break-inside-avoid mb-1">
        <i class="block bg-neutral-800" style="padding-bottom:{{ img.height | times: 100 | divided_by: img.width }}%"></i>
        <img
          src="{{ img.preview.url }}"
          alt="{{ gallery.title }}"
          loading="lazy"
          class="gallery-img absolute top-0 w-full h-auto cursor-pointer hover:brightness-75 transition-filter duration-200"
          onclick="openLightbox('{{ img.url }}', {{ image_index }})" />
      </div>
      {% assign image_index = image_index | plus: 1 %}
    {% endfor %}
  </div>
</div>{% endif %}<!-- Enhanced Lightbox with Navigation and Zoom -->
<div
  id="lightbox"
  class="fixed inset-0 bg-black/90 hidden items-center justify-center z-[9999]"
  onclick="handleLightboxClick(event)">

<!-- Navigation Chevrons -->
<button
  id="prevBtn"
  onclick="navigateImage(-1)"
  class="absolute left-4 top-1/2 -translate-y-1/2 z-[10001] bg-black/50 text-white p-3 hover:bg-black/70 transition-colors duration-200"
  style="display: none;">
  <!-- Left Chevron SVG -->
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="square"
    stroke-linejoin="miter">
    <path d="m15 18-6-6 6-6" />
  </svg>
</button>

<button
  id="nextBtn"
  onclick="navigateImage(1)"
  class="absolute right-4 top-1/2 -translate-y-1/2 z-[10001] bg-black/50 text-white p-3 hover:bg-black/70 transition-colors duration-200"
  style="display: none;">
  <!-- Right Chevron SVG -->
  <svg
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="square"
    stroke-linejoin="miter">
    <path d="m9 18 6-6-6-6" />
  </svg>
</button>

<!-- Top Controls -->
<div class="absolute top-5 right-5 flex gap-2 z-[10000]">
  <a
    id="downloadBtn"
    href="#"
    onclick="downloadImage(event)">
    <button class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
      <!-- Download Icon -->
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="w-5 h-5"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor">
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5 5-5M12 15V3" />
      </svg>
    </button>
  </a>
  <button onclick="closeLightbox()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <!-- Close Icon -->
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="w-5 h-5"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor">
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M6 18L18 6M6 6l12 12" />
    </svg>
  </button>
</div>

<!-- Image Container with Zoom -->
<div id="imageContainer" class="relative w-full h-full flex items-center justify-center overflow-hidden">
  <img
    id="lightboxImg"
    src=""
    alt="Expanded image"
    class="max-w-[90vw] max-h-[90vh] object-contain transition-transform duration-200 cursor-grab active:cursor-grabbing"
    style="transform-origin: center;" />
</div>

<!-- Zoom Controls -->
<div class="absolute bottom-5 left-1/2 -translate-x-1/2 flex gap-2 z-[10000]">
  <button onclick="zoomOut()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <svg
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2">
      <circle
        cx="11"
        cy="11"
        r="8" />
      <path d="m21 21-4.35-4.35" />
      <line
        x1="8"
        y1="11"
        x2="14"
        y2="11" />
    </svg>
  </button>
  <button onclick="resetZoom()" class="bg-white/20 text-white px-4 h-10 flex items-center justify-center hover:bg-white/30 transition-colors duration-200 text-sm font-mono">
    <span id="zoomPercentage">100%</span>
  </button>
  <button onclick="zoomIn()" class="bg-white/20 text-white w-10 aspect-square flex items-center justify-center hover:bg-white/30 transition-colors duration-200">
    <svg
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2">
      <circle
        cx="11"
        cy="11"
        r="8" />
      <path d="m21 21-4.35-4.35" />
      <line
        x1="11"
        y1="8"
        x2="11"
        y2="14" />
      <line
        x1="8"
        y1="11"
        x2="14"
        y2="11" />
    </svg>
  </button>
</div></div><script>
  let currentImageIndex = 0;
  let currentZoom = 1;
  let isDragging = false;
  let translateX = 0;
  let translateY = 0;
  let lastTranslateX = 0;
  let lastTranslateY = 0;
  const preloadedImages = new Map();

  {% if gallery.locked %}
  let galleryImages = [];
  {% else %}
  const galleryImages = [
    {% assign image_index = 0 %}
    {% for img in gallery.images %}
      "{{ img.url }}"{% unless forloop.last %},{% endunless %}
    {% endfor %}
  ];
  {% endif %}

  function preloadImage(src) {
    if (preloadedImages.has(src)) return;
    
    const img = new Image();
    img.src = src;
    preloadedImages.set(src, img);
  }

  function preloadAdjacentImages() {
    if (galleryImages.length <= 1) return;

    const prevIndex = currentImageIndex === 0 ? galleryImages.length - 1 : currentImageIndex - 1;
    const nextIndex = currentImageIndex === galleryImages.length - 1 ? 0 : currentImageIndex + 1;

    preloadImage(galleryImages[prevIndex]);
    preloadImage(galleryImages[nextIndex]);
  }

  function openLightbox(src, index = 0) {
    const lb = document.getElementById("lightbox");
    if (!lb) return;

    currentImageIndex = index;
    resetZoom();

    lb.classList.remove("hidden");
    lb.classList.add("flex");

    loadImage(src);
    updateNavigationButtons();
    updateZoomPercentage();
    preloadAdjacentImages();

    document.addEventListener("keydown", handleKeyPress);
  }

  function loadImage(src) {
    const img = document.getElementById("lightboxImg");
    const downloadBtn = document.getElementById("downloadBtn");

    img.src = "";
    img.style.transform = "scale(1) translate(0px, 0px)";
    img.onload = () => img.style.opacity = "1";

    img.style.opacity = "0.5";
    img.src = src;
    downloadBtn.href = src;
  }

  function closeLightbox() {
    const lb = document.getElementById("lightbox");
    if (!lb) return;

    lb.classList.remove("flex");
    lb.classList.add("hidden");
    document.getElementById("lightboxImg").src = "";
    document.getElementById("downloadBtn").href = "#";

    document.removeEventListener("keydown", handleKeyPress);
  }

  function navigateImage(direction) {
    if (galleryImages.length <= 1) return;

    currentImageIndex += direction;
    if (currentImageIndex < 0) currentImageIndex = galleryImages.length - 1;
    if (currentImageIndex >= galleryImages.length) currentImageIndex = 0;

    resetZoom();
    loadImage(galleryImages[currentImageIndex]);
    updateNavigationButtons();
    updateZoomPercentage();
    preloadAdjacentImages();
  }

  function updateNavigationButtons() {
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    if (galleryImages.length > 1) {
      prevBtn.style.display = "block";
      nextBtn.style.display = "block";
    } else {
      prevBtn.style.display = "none";
      nextBtn.style.display = "none";
    }
  }

  function handleLightboxClick(event) {
    if (event.target.id === "lightbox" || event.target.id === "imageContainer") {
      closeLightbox();
    }
  }

  function downloadImage(event) {
    event.preventDefault();
    event.stopPropagation();

    const url = document.getElementById("lightboxImg").src;
    const fileName = url.split('/').pop();
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    if (isIOS || isSafari) {
      window.open(url, "_blank");
      return;
    }

    fetch(url).then(res => res.blob()).then(blob => {
      const blobUrl = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = blobUrl;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(blobUrl);
    }).catch(err => console.error("Download failed:", err));
  }

  // Zoom controls
  function zoomIn() {
    currentZoom = Math.min(currentZoom * 1.5, 5);
    updateImageTransform();
    updateZoomPercentage();
  }

  function zoomOut() {
    currentZoom = Math.max(currentZoom / 1.5, 0.5);
    updateImageTransform();
    updateZoomPercentage();
  }

  function resetZoom() {
    currentZoom = 1;
    translateX = 0;
    translateY = 0;
    lastTranslateX = 0;
    lastTranslateY = 0;
    updateImageTransform();
    updateZoomPercentage();
  }

  function zoomToPoint(clientX, clientY, zoomLevel) {
    const img = document.getElementById("lightboxImg");
    const rect = img.getBoundingClientRect();
    const imgCenterX = rect.left + rect.width / 2;
    const imgCenterY = rect.top + rect.height / 2;

    const offsetX = (clientX - imgCenterX) / currentZoom;
    const offsetY = (clientY - imgCenterY) / currentZoom;

    currentZoom = Math.min(Math.max(zoomLevel, 0.5), 5);
    translateX -= offsetX * (currentZoom - 1);
    translateY -= offsetY * (currentZoom - 1);
    lastTranslateX = translateX;
    lastTranslateY = translateY;

    updateImageTransform();
    updateZoomPercentage();
  }

  function updateZoomPercentage() {
    document.getElementById("zoomPercentage").textContent = Math.round(currentZoom * 100) + "%";
  }

  function updateImageTransform() {
    const img = document.getElementById("lightboxImg");
    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentZoom})`;
    img.style.cursor = currentZoom > 1 ? (isDragging ? "grabbing" : "grab") : "zoom-in";
  }

  // Wheel zoom
  document.getElementById("imageContainer").addEventListener("wheel", function(e) {
    e.preventDefault();
    if (e.deltaY < 0) zoomToPoint(e.clientX, e.clientY, currentZoom * 1.2);
    else zoomToPoint(e.clientX, e.clientY, currentZoom / 1.2);
  }, { passive: false });

  // ---- Mouse Drag + Click-to-Zoom ----
  const img = document.getElementById("lightboxImg");
  img.addEventListener("mousedown", (e) => {
    e.preventDefault();
    let moved = false;
    isDragging = true;

    const startX = e.clientX;
    const startY = e.clientY;
    const originX = translateX;
    const originY = translateY;

    const handleMouseMove = (e) => {
      moved = true;
      translateX = originX + (e.clientX - startX);
      translateY = originY + (e.clientY - startY);
      lastTranslateX = translateX;
      lastTranslateY = translateY;
      updateImageTransform();
    };

    const handleMouseUp = (e) => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      isDragging = false;

      // If no drag happened ‚Üí treat as click-to-zoom
      if (!moved) {
        if (currentZoom === 1) {
          zoomToPoint(e.clientX, e.clientY, 2);
        } else {
          resetZoom();
        }
      }
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  });

  // ---- Touch: drag + pinch zoom ----
  let pinchStartDist = 0;
  let pinchStartZoom = 1;
  let originX = 0, originY = 0, startX = 0, startY = 0;

  img.addEventListener("touchstart", (e) => {
    if (e.touches.length === 2) {
      pinchStartDist = getTouchDistance(e.touches[0], e.touches[1]);
      pinchStartZoom = currentZoom;
    } else if (e.touches.length === 1) {
      isDragging = true;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      originX = translateX;
      originY = translateY;
    }
  }, { passive: false });

  img.addEventListener("touchmove", (e) => {
    if (e.touches.length === 2) {
      const newDist = getTouchDistance(e.touches[0], e.touches[1]);
      const ratio = newDist / pinchStartDist;
      currentZoom = Math.min(Math.max(pinchStartZoom * ratio, 0.5), 5);
      updateImageTransform();
      updateZoomPercentage();
    } else if (isDragging && e.touches.length === 1) {
      translateX = originX + (e.touches[0].clientX - startX);
      translateY = originY + (e.touches[0].clientY - startY);
      lastTranslateX = translateX;
      lastTranslateY = translateY;
      updateImageTransform();
    }
  }, { passive: false });

  img.addEventListener("touchend", () => {
    isDragging = false;
  });

  function getTouchDistance(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Keyboard navigation
  function handleKeyPress(e) {
    switch(e.key) {
      case "Escape": closeLightbox(); break;
      case "ArrowLeft": navigateImage(-1); break;
      case "ArrowRight": navigateImage(1); break;
      case "+": case "=": zoomIn(); break;
      case "-": zoomOut(); break;
      case "0": resetZoom(); break;
    }
  }
</script>